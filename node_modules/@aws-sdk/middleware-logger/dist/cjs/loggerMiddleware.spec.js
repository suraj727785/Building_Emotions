"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const loggerMiddleware_1 = require("./loggerMiddleware");
describe("getLoggerPlugin", () => {
    const mockClientStack = {
        add: jest.fn(),
    };
    afterEach(() => {
        jest.clearAllMocks();
    });
    it("adds loggerMiddleware", () => {
        loggerMiddleware_1.getLoggerPlugin({}).applyToStack(mockClientStack);
        expect(mockClientStack.add).toHaveBeenCalledTimes(1);
        expect(mockClientStack.add.mock.calls[0][1]).toEqual(loggerMiddleware_1.loggerMiddlewareOptions);
    });
});
describe("loggerMiddleware", () => {
    const mockNext = jest.fn();
    const mockArgs = {
        input: {
            inputKey: "inputValue",
        },
        request: {
            method: "GET",
            headers: {},
        },
    };
    const mockResponse = {
        response: {
            statusCode: 200,
            headers: {
                "x-amzn-requestid": "requestId",
                "x-amz-id-2": "extendedRequestId",
                "x-amz-cf-id": "cfId",
            },
        },
        output: {
            outputKey: "outputValue",
        },
    };
    afterEach(() => {
        jest.clearAllMocks();
    });
    it("returns without logging if context.logger is not defined", async () => {
        mockNext.mockResolvedValueOnce(mockResponse);
        const response = await loggerMiddleware_1.loggerMiddleware()(mockNext, {})(mockArgs);
        expect(mockNext).toHaveBeenCalledTimes(1);
        expect(response).toStrictEqual(mockResponse);
    });
    it("returns without logging if context.logger doesn't have info function", async () => {
        mockNext.mockResolvedValueOnce(mockResponse);
        const logger = {};
        const response = await loggerMiddleware_1.loggerMiddleware()(mockNext, { logger })(mockArgs);
        expect(mockNext).toHaveBeenCalledTimes(1);
        expect(response).toStrictEqual(mockResponse);
    });
    it("logs metadata if context.logger has info function", async () => {
        mockNext.mockResolvedValueOnce(mockResponse);
        const logger = { info: jest.fn() };
        const context = {
            logger,
        };
        const response = await loggerMiddleware_1.loggerMiddleware()(mockNext, context)(mockArgs);
        expect(mockNext).toHaveBeenCalledTimes(1);
        expect(response).toStrictEqual(mockResponse);
        expect(logger.info).toHaveBeenCalledTimes(1);
        expect(logger.info).toHaveBeenCalledWith({
            metadata: {
                statusCode: mockResponse.response.statusCode,
                requestId: mockResponse.response.headers["x-amzn-requestid"],
                extendedRequestId: mockResponse.response.headers["x-amz-id-2"],
                cfId: mockResponse.response.headers["x-amz-cf-id"],
            },
        });
    });
    it("logs header x-amzn-request-id as requestId if x-amzn-requestid is not present", async () => {
        const requestIdBackup = "requestIdBackup";
        const customResponse = {
            ...mockResponse,
            response: {
                ...mockResponse.response,
                headers: {
                    "x-amzn-request-id": requestIdBackup,
                },
            },
        };
        mockNext.mockResolvedValueOnce(customResponse);
        const logger = { info: jest.fn() };
        const context = {
            logger,
        };
        const response = await loggerMiddleware_1.loggerMiddleware()(mockNext, context)(mockArgs);
        expect(mockNext).toHaveBeenCalledTimes(1);
        expect(response).toStrictEqual(customResponse);
        expect(logger.info).toHaveBeenCalledTimes(1);
        expect(logger.info).toHaveBeenCalledWith({
            metadata: {
                statusCode: customResponse.response.statusCode,
                requestId: requestIdBackup,
                extendedRequestId: undefined,
                cfId: undefined,
            },
        });
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9nZ2VyTWlkZGxld2FyZS5zcGVjLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2xvZ2dlck1pZGRsZXdhcmUuc3BlYy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBLHlEQUFnRztBQUVoRyxRQUFRLENBQUMsaUJBQWlCLEVBQUUsR0FBRyxFQUFFO0lBQy9CLE1BQU0sZUFBZSxHQUFHO1FBQ3RCLEdBQUcsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO0tBQ2YsQ0FBQztJQUVGLFNBQVMsQ0FBQyxHQUFHLEVBQUU7UUFDYixJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7SUFDdkIsQ0FBQyxDQUFDLENBQUM7SUFFSCxFQUFFLENBQUMsdUJBQXVCLEVBQUUsR0FBRyxFQUFFO1FBQy9CLGtDQUFlLENBQUMsRUFBRSxDQUFDLENBQUMsWUFBWSxDQUFFLGVBQXdELENBQUMsQ0FBQztRQUM1RixNQUFNLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3JELE1BQU0sQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsMENBQXVCLENBQUMsQ0FBQztJQUNoRixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDO0FBRUgsUUFBUSxDQUFDLGtCQUFrQixFQUFFLEdBQUcsRUFBRTtJQUNoQyxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUM7SUFFM0IsTUFBTSxRQUFRLEdBQUc7UUFDZixLQUFLLEVBQUU7WUFDTCxRQUFRLEVBQUUsWUFBWTtTQUN2QjtRQUNELE9BQU8sRUFBRTtZQUNQLE1BQU0sRUFBRSxLQUFLO1lBQ2IsT0FBTyxFQUFFLEVBQUU7U0FDWjtLQUNGLENBQUM7SUFFRixNQUFNLFlBQVksR0FBRztRQUNuQixRQUFRLEVB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RTtnQkFDUixHQUFHLFlBQVksQ0FBQyxRQUFRO2dCQUN4QixPQUFPLEVBQUU7b0JBQ1AsbUJBQW1CLEVBQUUsZUFBZTtpQkFDckM7YUFDRjtTQUNGLENBQUM7UUFDRixRQUFRLENBQUMscUJBQXFCLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDL0MsTUFBTSxNQUFNLEdBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRSxFQUF3QixDQUFDO1FBRTFELE1BQU0sT0FBTyxHQUFHO1lBQ2QsTUFBTTtTQUNQLENBQUM7UUFFRixNQUFNLFFBQVEsR0FBRyxNQUFNLG1DQUFnQixFQUFFLENBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ3ZFLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMxQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsYUFBYSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBRS9DLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMscUJBQXFCLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFN0MsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxvQkFBb0IsQ0FBQztZQUN2QyxRQUFRLEVBQUU7Z0JBQ1IsVUFBVSxFQUFFLGNBQWMsQ0FBQyxRQUFRLENBQUMsVUFBVTtnQkFDOUMsU0FBUyxFQUFFLGVBQWU7Z0JBQzFCLGlCQUFpQixFQUFFLFNBQVM7Z0JBQzVCLElBQUksRUFBRSxTQUFTO2FBQ2hCO1NBQ0YsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExvZ2dlciwgTWlkZGxld2FyZVN0YWNrIH0gZnJvbSBcIkBhd3Mtc2RrL3R5cGVzXCI7XG5cbmltcG9ydCB7IGdldExvZ2dlclBsdWdpbiwgbG9nZ2VyTWlkZGxld2FyZSwgbG9nZ2VyTWlkZGxld2FyZU9wdGlvbnMgfSBmcm9tIFwiLi9sb2dnZXJNaWRkbGV3YXJlXCI7XG5cbmRlc2NyaWJlKFwiZ2V0TG9nZ2VyUGx1Z2luXCIsICgpID0+IHtcbiAgY29uc3QgbW9ja0NsaWVudFN0YWNrID0ge1xuICAgIGFkZDogamVzdC5mbigpLFxuICB9O1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gIH0pO1xuXG4gIGl0KFwiYWRkcyBsb2dnZXJNaWRkbGV3YXJlXCIsICgpID0+IHtcbiAgICBnZXRMb2dnZXJQbHVnaW4oe30pLmFwcGx5VG9TdGFjaygobW9ja0NsaWVudFN0YWNrIGFzIHVua25vd24pIGFzIE1pZGRsZXdhcmVTdGFjazxhbnksIGFueT4pO1xuICAgIGV4cGVjdChtb2NrQ2xpZW50U3RhY2suYWRkKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgZXhwZWN0KG1vY2tDbGllbnRTdGFjay5hZGQubW9jay5jYWxsc1swXVsxXSkudG9FcXVhbChsb2dnZXJNaWRkbGV3YXJlT3B0aW9ucyk7XG4gIH0pO1xufSk7XG5cbmRlc2NyaWJlKFwibG9nZ2VyTWlkZGxld2FyZVwiLCAoKSA9PiB7XG4gIGNvbnN0IG1vY2tOZXh0ID0gamVzdC5mbigpO1xuXG4gIGNvbnN0IG1vY2tBcmdzID0ge1xuICAgIGlucHV0OiB7XG4gICAgICBpbnB1dEtleTogXCJpbnB1dFZhbHVlXCIsXG4gICAgfSxcbiAgICByZXF1ZXN0OiB7XG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICBoZWFkZXJzOiB7fSxcbiAgICB9LFxuICB9O1xuXG4gIGNvbnN0IG1vY2tSZXNwb25zZSA9IHtcbiAgICByZXNwb25zZToge1xuICAgICAgc3RhdHVzQ29kZTogMjAwLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIngtYW16bi1yZXF1ZXN0aWRcIjogXCJyZXF1ZXN0SWRcIixcbiAgICAgICAgXCJ4LWFtei1pZC0yXCI6IFwiZXh0ZW5kZWRSZXF1ZXN0SWRcIixcbiAgICAgICAgXCJ4LWFtei1jZi1pZFwiOiBcImNmSWRcIixcbiAgICAgIH0sXG4gICAgfSxcbiAgICBvdXRwdXQ6IHtcbiAgICAgIG91dHB1dEtleTogXCJvdXRwdXRWYWx1ZVwiLFxuICAgIH0sXG4gIH07XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgaXQoXCJyZXR1cm5zIHdpdGhvdXQgbG9nZ2luZyBpZiBjb250ZXh0LmxvZ2dlciBpcyBub3QgZGVmaW5lZFwiLCBhc3luYyAoKSA9PiB7XG4gICAgbW9ja05leHQubW9ja1Jlc29sdmVkVmFsdWVPbmNlKG1vY2tSZXNwb25zZSk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBsb2dnZXJNaWRkbGV3YXJlKCkobW9ja05leHQsIHt9KShtb2NrQXJncyk7XG4gICAgZXhwZWN0KG1vY2tOZXh0KS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgZXhwZWN0KHJlc3BvbnNlKS50b1N0cmljdEVxdWFsKG1vY2tSZXNwb25zZSk7XG4gIH0pO1xuXG4gIGl0KFwicmV0dXJucyB3aXRob3V0IGxvZ2dpbmcgaWYgY29udGV4dC5sb2dnZXIgZG9lc24ndCBoYXZlIGluZm8gZnVuY3Rpb25cIiwgYXN5bmMgKCkgPT4ge1xuICAgIG1vY2tOZXh0Lm1vY2tSZXNvbHZlZFZhbHVlT25jZShtb2NrUmVzcG9uc2UpO1xuICAgIGNvbnN0IGxvZ2dlciA9IHt9IGFzIExvZ2dlcjtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGxvZ2dlck1pZGRsZXdhcmUoKShtb2NrTmV4dCwgeyBsb2dnZXIgfSkobW9ja0FyZ3MpO1xuICAgIGV4cGVjdChtb2NrTmV4dCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgIGV4cGVjdChyZXNwb25zZSkudG9TdHJpY3RFcXVhbChtb2NrUmVzcG9uc2UpO1xuICB9KTtcblxuICBpdChcImxvZ3MgbWV0YWRhdGEgaWYgY29udGV4dC5sb2dnZXIgaGFzIGluZm8gZnVuY3Rpb25cIiwgYXN5bmMgKCkgPT4ge1xuICAgIG1vY2tOZXh0Lm1vY2tSZXNvbHZlZFZhbHVlT25jZShtb2NrUmVzcG9uc2UpO1xuICAgIGNvbnN0IGxvZ2dlciA9ICh7IGluZm86IGplc3QuZm4oKSB9IGFzIHVua25vd24pIGFzIExvZ2dlcjtcblxuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBsb2dnZXIsXG4gICAgfTtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbG9nZ2VyTWlkZGxld2FyZSgpKG1vY2tOZXh0LCBjb250ZXh0KShtb2NrQXJncyk7XG4gICAgZXhwZWN0KG1vY2tOZXh0KS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgZXhwZWN0KHJlc3BvbnNlKS50b1N0cmljdEVxdWFsKG1vY2tSZXNwb25zZSk7XG5cbiAgICBleHBlY3QobG9nZ2VyLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcblxuICAgIGV4cGVjdChsb2dnZXIuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgc3RhdHVzQ29kZTogbW9ja1Jlc3BvbnNlLnJlc3BvbnNlLnN0YXR1c0NvZGUsXG4gICAgICAgIHJlcXVlc3RJZDogbW9ja1Jlc3BvbnNlLnJlc3BvbnNlLmhlYWRlcnNbXCJ4LWFtem4tcmVxdWVzdGlkXCJdLFxuICAgICAgICBleHRlbmRlZFJlcXVlc3RJZDogbW9ja1Jlc3BvbnNlLnJlc3BvbnNlLmhlYWRlcnNbXCJ4LWFtei1pZC0yXCJdLFxuICAgICAgICBjZklkOiBtb2NrUmVzcG9uc2UucmVzcG9uc2UuaGVhZGVyc1tcIngtYW16LWNmLWlkXCJdLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfSk7XG5cbiAgaXQoXCJsb2dzIGhlYWRlciB4LWFtem4tcmVxdWVzdC1pZCBhcyByZXF1ZXN0SWQgaWYgeC1hbXpuLXJlcXVlc3RpZCBpcyBub3QgcHJlc2VudFwiLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgcmVxdWVzdElkQmFja3VwID0gXCJyZXF1ZXN0SWRCYWNrdXBcIjtcbiAgICBjb25zdCBjdXN0b21SZXNwb25zZSA9IHtcbiAgICAgIC4uLm1vY2tSZXNwb25zZSxcbiAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgIC4uLm1vY2tSZXNwb25zZS5yZXNwb25zZSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwieC1hbXpuLXJlcXVlc3QtaWRcIjogcmVxdWVzdElkQmFja3VwLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9O1xuICAgIG1vY2tOZXh0Lm1vY2tSZXNvbHZlZFZhbHVlT25jZShjdXN0b21SZXNwb25zZSk7XG4gICAgY29uc3QgbG9nZ2VyID0gKHsgaW5mbzogamVzdC5mbigpIH0gYXMgdW5rbm93bikgYXMgTG9nZ2VyO1xuXG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIGxvZ2dlcixcbiAgICB9O1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBsb2dnZXJNaWRkbGV3YXJlKCkobW9ja05leHQsIGNvbnRleHQpKG1vY2tBcmdzKTtcbiAgICBleHBlY3QobW9ja05leHQpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICBleHBlY3QocmVzcG9uc2UpLnRvU3RyaWN0RXF1YWwoY3VzdG9tUmVzcG9uc2UpO1xuXG4gICAgZXhwZWN0KGxvZ2dlci5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG5cbiAgICBleHBlY3QobG9nZ2VyLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIHN0YXR1c0NvZGU6IGN1c3RvbVJlc3BvbnNlLnJlc3BvbnNlLnN0YXR1c0NvZGUsXG4gICAgICAgIHJlcXVlc3RJZDogcmVxdWVzdElkQmFja3VwLFxuICAgICAgICBleHRlbmRlZFJlcXVlc3RJZDogdW5kZWZpbmVkLFxuICAgICAgICBjZklkOiB1bmRlZmluZWQsXG4gICAgICB9LFxuICAgIH0pO1xuICB9KTtcbn0pO1xuIl19