import { __awaiter, __generator } from "tslib";
import { toHex } from "@aws-sdk/util-hex-encoding";
import { ALGORITHM_IDENTIFIER, ALGORITHM_QUERY_PARAM, AMZ_DATE_HEADER, AMZ_DATE_QUERY_PARAM, AUTH_HEADER, CREDENTIAL_QUERY_PARAM, EVENT_ALGORITHM_IDENTIFIER, EXPIRES_QUERY_PARAM, MAX_PRESIGNED_TTL, SHA256_HEADER, SIGNATURE_QUERY_PARAM, SIGNED_HEADERS_QUERY_PARAM, TOKEN_HEADER, TOKEN_QUERY_PARAM, } from "./constants";
import { createScope, getSigningKey } from "./credentialDerivation";
import { getCanonicalHeaders } from "./getCanonicalHeaders";
import { getCanonicalQuery } from "./getCanonicalQuery";
import { getPayloadHash } from "./getPayloadHash";
import { hasHeader } from "./hasHeader";
import { moveHeadersToQuery } from "./moveHeadersToQuery";
import { prepareRequest } from "./prepareRequest";
import { iso8601 } from "./utilDate";
var SignatureV4 = /** @class */ (function () {
    function SignatureV4(_a) {
        var applyChecksum = _a.applyChecksum, credentials = _a.credentials, region = _a.region, service = _a.service, sha256 = _a.sha256, _b = _a.uriEscapePath, uriEscapePath = _b === void 0 ? true : _b;
        this.service = service;
        this.sha256 = sha256;
        this.uriEscapePath = uriEscapePath;
        // default to true if applyChecksum isn't set
        this.applyChecksum = typeof applyChecksum === "boolean" ? applyChecksum : true;
        this.regionProvider = normalizeRegionProvider(region);
        this.credentialProvider = normalizeCredentialsProvider(credentials);
    }
    SignatureV4.prototype.presign = function (originalRequest, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, signingDate, _b, expiresIn, unsignableHeaders, signableHeaders, signingRegion, signingService, credentials, region, _c, _d, longDate, shortDate, scope, request, canonicalHeaders, _e, _f, _g, _h, _j, _k;
            return __generator(this, function (_l) {
                switch (_l.label) {
                    case 0:
                        _a = options.signingDate, signingDate = _a === void 0 ? new Date() : _a, _b = options.expiresIn, expiresIn = _b === void 0 ? 3600 : _b, unsignableHeaders = options.unsignableHeaders, signableHeaders = options.signableHeaders, signingRegion = options.signingRegion, signingService = options.signingService;
                        return [4 /*yield*/, this.credentialProvider()];
                    case 1:
                        credentials = _l.sent();
                        if (!(signingRegion !== null && signingRegion !== void 0)) return [3 /*break*/, 2];
                        _c = signingRegion;
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, this.regionProvider()];
                    case 3:
                        _c = (_l.sent());
                        _l.label = 4;
                    case 4:
                        region = _c;
                        _d = formatDate(signingDate), longDate = _d.longDate, shortDate = _d.shortDate;
                        if (expiresIn > MAX_PRESIGNED_TTL) {
                            return [2 /*return*/, Promise.reject("Signature version 4 presigned URLs" + " must have an expiration date less than one week in" + " the future")];
                        }
                        scope = createScope(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);
                        request = moveHeadersToQuery(prepareRequest(originalRequest));
                        if (credentials.sessionToken) {
                            request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;
                        }
                        request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;
                        request.query[CREDENTIAL_QUERY_PARAM] = credentials.accessKeyId + "/" + scope;
                        request.query[AMZ_DATE_QUERY_PARAM] = longDate;
                        request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);
                        canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
                        request.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);
                        _e = request.query;
                        _f = SIGNATURE_QUERY_PARAM;
                        _g = this.getSignature;
                        _h = [longDate,
                            scope,
                            this.getSigningKey(credentials, region, shortDate, signingService)];
                        _j = this.createCanonicalRequest;
                        _k = [request, canonicalHeaders];
                        return [4 /*yield*/, getPayloadHash(originalRequest, this.sha256)];
                    case 5: return [4 /*yield*/, _g.apply(this, _h.concat([_j.apply(this, _k.concat([_l.sent()]))]))];
                    case 6:
                        _e[_f] = _l.sent();
                        return [2 /*return*/, request];
                }
            });
        });
    };
    SignatureV4.prototype.sign = function (toSign, options) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (typeof toSign === "string") {
                    return [2 /*return*/, this.signString(toSign, options)];
                }
                else if (toSign.headers && toSign.payload) {
                    return [2 /*return*/, this.signEvent(toSign, options)];
                }
                else {
                    return [2 /*return*/, this.signRequest(toSign, options)];
                }
                return [2 /*return*/];
            });
        });
    };
    SignatureV4.prototype.signEvent = function (_a, _b) {
        var headers = _a.headers, payload = _a.payload;
        var _c = _b.signingDate, signingDate = _c === void 0 ? new Date() : _c, priorSignature = _b.priorSignature, signingRegion = _b.signingRegion, signingService = _b.signingService;
        return __awaiter(this, void 0, void 0, function () {
            var region, _d, _e, shortDate, longDate, scope, hashedPayload, hash, hashedHeaders, _f, stringToSign;
            return __generator(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        if (!(signingRegion !== null && signingRegion !== void 0)) return [3 /*break*/, 1];
                        _d = signingRegion;
                        return [3 /*break*/, 3];
                    case 1: return [4 /*yield*/, this.regionProvider()];
                    case 2:
                        _d = (_g.sent());
                        _g.label = 3;
                    case 3:
                        region = _d;
                        _e = formatDate(signingDate), shortDate = _e.shortDate, longDate = _e.longDate;
                        scope = createScope(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);
                        return [4 /*yield*/, getPayloadHash({ headers: {}, body: payload }, this.sha256)];
                    case 4:
                        hashedPayload = _g.sent();
                        hash = new this.sha256();
                        hash.update(headers);
                        _f = toHex;
                        return [4 /*yield*/, hash.digest()];
                    case 5:
                        hashedHeaders = _f.apply(void 0, [_g.sent()]);
                        stringToSign = [
                            EVENT_ALGORITHM_IDENTIFIER,
                            longDate,
                            scope,
                            priorSignature,
                            hashedHeaders,
                            hashedPayload,
                        ].join("\n");
                        return [2 /*return*/, this.signString(stringToSign, { signingDate: signingDate, signingRegion: region, signingService: signingService })];
                }
            });
        });
    };
    SignatureV4.prototype.signString = function (stringToSign, _a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.signingDate, signingDate = _c === void 0 ? new Date() : _c, signingRegion = _b.signingRegion, signingService = _b.signingService;
        return __awaiter(this, void 0, void 0, function () {
            var credentials, region, _d, shortDate, hash, _e, _f, _g;
            return __generator(this, function (_h) {
                switch (_h.label) {
                    case 0: return [4 /*yield*/, this.credentialProvider()];
                    case 1:
                        credentials = _h.sent();
                        if (!(signingRegion !== null && signingRegion !== void 0)) return [3 /*break*/, 2];
                        _d = signingRegion;
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, this.regionProvider()];
                    case 3:
                        _d = (_h.sent());
                        _h.label = 4;
                    case 4:
                        region = _d;
                        shortDate = formatDate(signingDate).shortDate;
                        _f = (_e = this.sha256).bind;
                        return [4 /*yield*/, this.getSigningKey(credentials, region, shortDate, signingService)];
                    case 5:
                        hash = new (_f.apply(_e, [void 0, _h.sent()]))();
                        hash.update(stringToSign);
                        _g = toHex;
                        return [4 /*yield*/, hash.digest()];
                    case 6: return [2 /*return*/, _g.apply(void 0, [_h.sent()])];
                }
            });
        });
    };
    SignatureV4.prototype.signRequest = function (requestToSign, _a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.signingDate, signingDate = _c === void 0 ? new Date() : _c, signableHeaders = _b.signableHeaders, unsignableHeaders = _b.unsignableHeaders, signingRegion = _b.signingRegion, signingService = _b.signingService;
        return __awaiter(this, void 0, void 0, function () {
            var credentials, region, _d, request, _e, longDate, shortDate, scope, payloadHash, canonicalHeaders, signature;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0: return [4 /*yield*/, this.credentialProvider()];
                    case 1:
                        credentials = _f.sent();
                        if (!(signingRegion !== null && signingRegion !== void 0)) return [3 /*break*/, 2];
                        _d = signingRegion;
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, this.regionProvider()];
                    case 3:
                        _d = (_f.sent());
                        _f.label = 4;
                    case 4:
                        region = _d;
                        request = prepareRequest(requestToSign);
                        _e = formatDate(signingDate), longDate = _e.longDate, shortDate = _e.shortDate;
                        scope = createScope(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);
                        request.headers[AMZ_DATE_HEADER] = longDate;
                        if (credentials.sessionToken) {
                            request.headers[TOKEN_HEADER] = credentials.sessionToken;
                        }
                        return [4 /*yield*/, getPayloadHash(request, this.sha256)];
                    case 5:
                        payloadHash = _f.sent();
                        if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {
                            request.headers[SHA256_HEADER] = payloadHash;
                        }
                        canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
                        return [4 /*yield*/, this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash))];
                    case 6:
                        signature = _f.sent();
                        request.headers[AUTH_HEADER] =
                            ALGORITHM_IDENTIFIER + " " +
                                ("Credential=" + credentials.accessKeyId + "/" + scope + ", ") +
                                ("SignedHeaders=" + getCanonicalHeaderList(canonicalHeaders) + ", ") +
                                ("Signature=" + signature);
                        return [2 /*return*/, request];
                }
            });
        });
    };
    SignatureV4.prototype.createCanonicalRequest = function (request, canonicalHeaders, payloadHash) {
        var sortedHeaders = Object.keys(canonicalHeaders).sort();
        return request.method + "\n" + this.getCanonicalPath(request) + "\n" + getCanonicalQuery(request) + "\n" + sortedHeaders.map(function (name) { return name + ":" + canonicalHeaders[name]; }).join("\n") + "\n\n" + sortedHeaders.join(";") + "\n" + payloadHash;
    };
    SignatureV4.prototype.createStringToSign = function (longDate, credentialScope, canonicalRequest) {
        return __awaiter(this, void 0, void 0, function () {
            var hash, hashedRequest;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        hash = new this.sha256();
                        hash.update(canonicalRequest);
                        return [4 /*yield*/, hash.digest()];
                    case 1:
                        hashedRequest = _a.sent();
                        return [2 /*return*/, ALGORITHM_IDENTIFIER + "\n" + longDate + "\n" + credentialScope + "\n" + toHex(hashedRequest)];
                }
            });
        });
    };
    SignatureV4.prototype.getCanonicalPath = function (_a) {
        var path = _a.path;
        if (this.uriEscapePath) {
            var doubleEncoded = encodeURIComponent(path.replace(/^\//, ""));
            return "/" + doubleEncoded.replace(/%2F/g, "/");
        }
        return path;
    };
    SignatureV4.prototype.getSignature = function (longDate, credentialScope, keyPromise, canonicalRequest) {
        return __awaiter(this, void 0, void 0, function () {
            var stringToSign, hash, _a, _b, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0: return [4 /*yield*/, this.createStringToSign(longDate, credentialScope, canonicalRequest)];
                    case 1:
                        stringToSign = _d.sent();
                        _b = (_a = this.sha256).bind;
                        return [4 /*yield*/, keyPromise];
                    case 2:
                        hash = new (_b.apply(_a, [void 0, _d.sent()]))();
                        hash.update(stringToSign);
                        _c = toHex;
                        return [4 /*yield*/, hash.digest()];
                    case 3: return [2 /*return*/, _c.apply(void 0, [_d.sent()])];
                }
            });
        });
    };
    SignatureV4.prototype.getSigningKey = function (credentials, region, shortDate, service) {
        return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);
    };
    return SignatureV4;
}());
export { SignatureV4 };
var formatDate = function (now) {
    var longDate = iso8601(now).replace(/[\-:]/g, "");
    return {
        longDate: longDate,
        shortDate: longDate.substr(0, 8),
    };
};
var getCanonicalHeaderList = function (headers) { return Object.keys(headers).sort().join(";"); };
var normalizeRegionProvider = function (region) {
    if (typeof region === "string") {
        var promisified_1 = Promise.resolve(region);
        return function () { return promisified_1; };
    }
    else {
        return region;
    }
};
var normalizeCredentialsProvider = function (credentials) {
    if (typeof credentials === "object") {
        var promisified_2 = Promise.resolve(credentials);
        return function () { return promisified_2; };
    }
    else {
        return credentials;
    }
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2lnbmF0dXJlVjQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvU2lnbmF0dXJlVjQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQWlCQSxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFFbkQsT0FBTyxFQUNMLG9CQUFvQixFQUNwQixxQkFBcUIsRUFDckIsZUFBZSxFQUNmLG9CQUFvQixFQUNwQixXQUFXLEVBQ1gsc0JBQXNCLEVBQ3RCLDBCQUEwQixFQUMxQixtQkFBbUIsRUFDbkIsaUJBQWlCLEVBQ2pCLGFBQWEsRUFDYixxQkFBcUIsRUFDckIsMEJBQTBCLEVBQzFCLFlBQVksRUFDWixpQkFBaUIsR0FDbEIsTUFBTSxhQUFhLENBQUM7QUFDckIsT0FBTyxFQUFFLFdBQVcsRUFBRSxhQUFhLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUNwRSxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUM1RCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUN4RCxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDbEQsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUN4QyxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUMxRCxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDbEQsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLFlBQVksQ0FBQztBQWtEckM7SUFRRSxxQkFBWSxFQU84QjtZQU54QyxhQUFhLG1CQUFBLEVBQ2IsV0FBVyxpQkFBQSxFQUNYLE1BQU0sWUFBQSxFQUNOLE9BQU8sYUFBQSxFQUNQLE1BQU0sWUFBQSxFQUNOLHFCQUFvQixFQUFwQixhQUFhLG1CQUFHLElBQUksS0FBQTtRQUVwQixJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztRQUN2QixJ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UUFBUSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQ3BELE9BQU87UUFDTCxRQUFRLFVBQUE7UUFDUixTQUFTLEVBQUUsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0tBQ2pDLENBQUM7QUFDSixDQUFDLENBQUM7QUFFRixJQUFNLHNCQUFzQixHQUFHLFVBQUMsT0FBZSxJQUFhLE9BQUEsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQXJDLENBQXFDLENBQUM7QUFFbEcsSUFBTSx1QkFBdUIsR0FBRyxVQUFDLE1BQWlDO0lBQ2hFLElBQUksT0FBTyxNQUFNLEtBQUssUUFBUSxFQUFFO1FBQzlCLElBQU0sYUFBVyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDNUMsT0FBTyxjQUFNLE9BQUEsYUFBVyxFQUFYLENBQVcsQ0FBQztLQUMxQjtTQUFNO1FBQ0wsT0FBTyxNQUFNLENBQUM7S0FDZjtBQUNILENBQUMsQ0FBQztBQUVGLElBQU0sNEJBQTRCLEdBQUcsVUFBQyxXQUFnRDtJQUNwRixJQUFJLE9BQU8sV0FBVyxLQUFLLFFBQVEsRUFBRTtRQUNuQyxJQUFNLGFBQVcsR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ2pELE9BQU8sY0FBTSxPQUFBLGFBQVcsRUFBWCxDQUFXLENBQUM7S0FDMUI7U0FBTTtRQUNMLE9BQU8sV0FBVyxDQUFDO0tBQ3BCO0FBQ0gsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ3JlZGVudGlhbHMsXG4gIERhdGVJbnB1dCxcbiAgRXZlbnRTaWduZXIsXG4gIEV2ZW50U2lnbmluZ0FyZ3VtZW50cyxcbiAgRm9ybWF0dGVkRXZlbnQsXG4gIEhhc2hDb25zdHJ1Y3RvcixcbiAgSGVhZGVyQmFnLFxuICBIdHRwUmVxdWVzdCxcbiAgUHJvdmlkZXIsXG4gIFJlcXVlc3RQcmVzaWduZXIsXG4gIFJlcXVlc3RQcmVzaWduaW5nQXJndW1lbnRzLFxuICBSZXF1ZXN0U2lnbmVyLFxuICBSZXF1ZXN0U2lnbmluZ0FyZ3VtZW50cyxcbiAgU2lnbmluZ0FyZ3VtZW50cyxcbiAgU3RyaW5nU2lnbmVyLFxufSBmcm9tIFwiQGF3cy1zZGsvdHlwZXNcIjtcbmltcG9ydCB7IHRvSGV4IH0gZnJvbSBcIkBhd3Mtc2RrL3V0aWwtaGV4LWVuY29kaW5nXCI7XG5cbmltcG9ydCB7XG4gIEFMR09SSVRITV9JREVOVElGSUVSLFxuICBBTEdPUklUSE1fUVVFUllfUEFSQU0sXG4gIEFNWl9EQVRFX0hFQURFUixcbiAgQU1aX0RBVEVfUVVFUllfUEFSQU0sXG4gIEFVVEhfSEVBREVSLFxuICBDUkVERU5USUFMX1FVRVJZX1BBUkFNLFxuICBFVkVOVF9BTEdPUklUSE1fSURFTlRJRklFUixcbiAgRVhQSVJFU19RVUVSWV9QQVJBTSxcbiAgTUFYX1BSRVNJR05FRF9UVEwsXG4gIFNIQTI1Nl9IRUFERVIsXG4gIFNJR05BVFVSRV9RVUVSWV9QQVJBTSxcbiAgU0lHTkVEX0hFQURFUlNfUVVFUllfUEFSQU0sXG4gIFRPS0VOX0hFQURFUixcbiAgVE9LRU5fUVVFUllfUEFSQU0sXG59IGZyb20gXCIuL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgY3JlYXRlU2NvcGUsIGdldFNpZ25pbmdLZXkgfSBmcm9tIFwiLi9jcmVkZW50aWFsRGVyaXZhdGlvblwiO1xuaW1wb3J0IHsgZ2V0Q2Fub25pY2FsSGVhZGVycyB9IGZyb20gXCIuL2dldENhbm9uaWNhbEhlYWRlcnNcIjtcbmltcG9ydCB7IGdldENhbm9uaWNhbFF1ZXJ5IH0gZnJvbSBcIi4vZ2V0Q2Fub25pY2FsUXVlcnlcIjtcbmltcG9ydCB7IGdldFBheWxvYWRIYXNoIH0gZnJvbSBcIi4vZ2V0UGF5bG9hZEhhc2hcIjtcbmltcG9ydCB7IGhhc0hlYWRlciB9IGZyb20gXCIuL2hhc0hlYWRlclwiO1xuaW1wb3J0IHsgbW92ZUhlYWRlcnNUb1F1ZXJ5IH0gZnJvbSBcIi4vbW92ZUhlYWRlcnNUb1F1ZXJ5XCI7XG5pbXBvcnQgeyBwcmVwYXJlUmVxdWVzdCB9IGZyb20gXCIuL3ByZXBhcmVSZXF1ZXN0XCI7XG5pbXBvcnQgeyBpc284NjAxIH0gZnJvbSBcIi4vdXRpbERhdGVcIjtcblxuZXhwb3J0IGludGVyZmFjZSBTaWduYXR1cmVWNEluaXQge1xuICAvKipcbiAgICogVGhlIHNlcnZpY2Ugc2lnbmluZyBuYW1lLlxuICAgKi9cbiAgc2VydmljZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgcmVnaW9uIG5hbWUgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBiZVxuICAgKiByZXNvbHZlZCB3aXRoIHRoZSByZWdpb24gbmFtZS5cbiAgICovXG4gIHJlZ2lvbjogc3RyaW5nIHwgUHJvdmlkZXI8c3RyaW5nPjtcblxuICAvKipcbiAgICogVGhlIGNyZWRlbnRpYWxzIHdpdGggd2hpY2ggdGhlIHJlcXVlc3Qgc2hvdWxkIGJlIHNpZ25lZCBvciBhIGZ1bmN0aW9uXG4gICAqIHRoYXQgcmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdpdGggY3JlZGVudGlhbHMuXG4gICAqL1xuICBjcmVkZW50aWFsczogQ3JlZGVudGlhbHMgfCBQcm92aWRlcjxDcmVkZW50aWFscz47XG5cbiAgLyoqXG4gICAqIEEgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIGEgaGFzaCBvYmplY3QgdGhhdCB3aWxsIGNhbGN1bGF0ZSBTSEEtMjU2IEhNQUNcbiAgICogY2hlY2tzdW1zLlxuICAgKi9cbiAgc2hhMjU2PzogSGFzaENvbnN0cnVjdG9yO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHVyaS1lc2NhcGUgdGhlIHJlcXVlc3QgVVJJIHBhdGggYXMgcGFydCBvZiBjb21wdXRpbmcgdGhlXG4gICAqIGNhbm9uaWNhbCByZXF1ZXN0IHN0cmluZy4gVGhpcyBpcyByZXF1aXJlZCBmb3IgZXZlcnkgQVdTIHNlcnZpY2UsIGV4Y2VwdFxuICAgKiBBbWF6b24gUzMsIGFzIG9mIGxhdGUgMjAxNy5cbiAgICpcbiAgICogQGRlZmF1bHQgW3RydWVdXG4gICAqL1xuICB1cmlFc2NhcGVQYXRoPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogV2hldGhlciB0byBjYWxjdWxhdGUgYSBjaGVja3N1bSBvZiB0aGUgcmVxdWVzdCBib2R5IGFuZCBpbmNsdWRlIGl0IGFzXG4gICAqIGVpdGhlciBhIHJlcXVlc3QgaGVhZGVyICh3aGVuIHNpZ25pbmcpIG9yIGFzIGEgcXVlcnkgc3RyaW5nIHBhcmFtZXRlclxuICAgKiAod2hlbiBwcmVzaWduaW5nKS4gVGhpcyBpcyByZXF1aXJlZCBmb3IgQVdTIEdsYWNpZXIgYW5kIEFtYXpvbiBTMyBhbmQgb3B0aW9uYWwgZm9yXG4gICAqIGV2ZXJ5IG90aGVyIEFXUyBzZXJ2aWNlIGFzIG9mIGxhdGUgMjAxNy5cbiAgICpcbiAgICogQGRlZmF1bHQgW3RydWVdXG4gICAqL1xuICBhcHBseUNoZWNrc3VtPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTaWduYXR1cmVWNENyeXB0b0luaXQge1xuICBzaGEyNTY6IEhhc2hDb25zdHJ1Y3Rvcjtcbn1cblxuZXhwb3J0IGNsYXNzIFNpZ25hdHVyZVY0IGltcGxlbWVudHMgUmVxdWVzdFByZXNpZ25lciwgUmVxdWVzdFNpZ25lciwgU3RyaW5nU2lnbmVyLCBFdmVudFNpZ25lciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgc2VydmljZTogc3RyaW5nO1xuICBwcml2YXRlIHJlYWRvbmx5IHJlZ2lvblByb3ZpZGVyOiBQcm92aWRlcjxzdHJpbmc+O1xuICBwcml2YXRlIHJlYWRvbmx5IGNyZWRlbnRpYWxQcm92aWRlcjogUHJvdmlkZXI8Q3JlZGVudGlhbHM+O1xuICBwcml2YXRlIHJlYWRvbmx5IHNoYTI1NjogSGFzaENvbnN0cnVjdG9yO1xuICBwcml2YXRlIHJlYWRvbmx5IHVyaUVzY2FwZVBhdGg6IGJvb2xlYW47XG4gIHByaXZhdGUgcmVhZG9ubHkgYXBwbHlDaGVja3N1bTogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3Rvcih7XG4gICAgYXBwbHlDaGVja3N1bSxcbiAgICBjcmVkZW50aWFscyxcbiAgICByZWdpb24sXG4gICAgc2VydmljZSxcbiAgICBzaGEyNTYsXG4gICAgdXJpRXNjYXBlUGF0aCA9IHRydWUsXG4gIH06IFNpZ25hdHVyZVY0SW5pdCAmIFNpZ25hdHVyZVY0Q3J5cHRvSW5pdCkge1xuICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgdGhpcy5zaGEyNTYgPSBzaGEyNTY7XG4gICAgdGhpcy51cmlFc2NhcGVQYXRoID0gdXJpRXNjYXBlUGF0aDtcbiAgICAvLyBkZWZhdWx0IHRvIHRydWUgaWYgYXBwbHlDaGVja3N1bSBpc24ndCBzZXRcbiAgICB0aGlzLmFwcGx5Q2hlY2tzdW0gPSB0eXBlb2YgYXBwbHlDaGVja3N1bSA9PT0gXCJib29sZWFuXCIgPyBhcHBseUNoZWNrc3VtIDogdHJ1ZTtcbiAgICB0aGlzLnJlZ2lvblByb3ZpZGVyID0gbm9ybWFsaXplUmVnaW9uUHJvdmlkZXIocmVnaW9uKTtcbiAgICB0aGlzLmNyZWRlbnRpYWxQcm92aWRlciA9IG5vcm1hbGl6ZUNyZWRlbnRpYWxzUHJvdmlkZXIoY3JlZGVudGlhbHMpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHByZXNpZ24ob3JpZ2luYWxSZXF1ZXN0OiBIdHRwUmVxdWVzdCwgb3B0aW9uczogUmVxdWVzdFByZXNpZ25pbmdBcmd1bWVudHMgPSB7fSk6IFByb21pc2U8SHR0cFJlcXVlc3Q+IHtcbiAgICBjb25zdCB7XG4gICAgICBzaWduaW5nRGF0ZSA9IG5ldyBEYXRlKCksXG4gICAgICBleHBpcmVzSW4gPSAzNjAwLFxuICAgICAgdW5zaWduYWJsZUhlYWRlcnMsXG4gICAgICBzaWduYWJsZUhlYWRlcnMsXG4gICAgICBzaWduaW5nUmVnaW9uLFxuICAgICAgc2lnbmluZ1NlcnZpY2UsXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgY3JlZGVudGlhbHMgPSBhd2FpdCB0aGlzLmNyZWRlbnRpYWxQcm92aWRlcigpO1xuICAgIGNvbnN0IHJlZ2lvbiA9IHNpZ25pbmdSZWdpb24gPz8gKGF3YWl0IHRoaXMucmVnaW9uUHJvdmlkZXIoKSk7XG5cbiAgICBjb25zdCB7IGxvbmdEYXRlLCBzaG9ydERhdGUgfSA9IGZvcm1hdERhdGUoc2lnbmluZ0RhdGUpO1xuICAgIGlmIChleHBpcmVzSW4gPiBNQVhfUFJFU0lHTkVEX1RUTCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICBcIlNpZ25hdHVyZSB2ZXJzaW9uIDQgcHJlc2lnbmVkIFVSTHNcIiArIFwiIG11c3QgaGF2ZSBhbiBleHBpcmF0aW9uIGRhdGUgbGVzcyB0aGFuIG9uZSB3ZWVrIGluXCIgKyBcIiB0aGUgZnV0dXJlXCJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2NvcGUgPSBjcmVhdGVTY29wZShzaG9ydERhdGUsIHJlZ2lvbiwgc2lnbmluZ1NlcnZpY2UgPz8gdGhpcy5zZXJ2aWNlKTtcbiAgICBjb25zdCByZXF1ZXN0ID0gbW92ZUhlYWRlcnNUb1F1ZXJ5KHByZXBhcmVSZXF1ZXN0KG9yaWdpbmFsUmVxdWVzdCkpO1xuXG4gICAgaWYgKGNyZWRlbnRpYWxzLnNlc3Npb25Ub2tlbikge1xuICAgICAgcmVxdWVzdC5xdWVyeVtUT0tFTl9RVUVSWV9QQVJBTV0gPSBjcmVkZW50aWFscy5zZXNzaW9uVG9rZW47XG4gICAgfVxuICAgIHJlcXVlc3QucXVlcnlbQUxHT1JJVEhNX1FVRVJZX1BBUkFNXSA9IEFMR09SSVRITV9JREVOVElGSUVSO1xuICAgIHJlcXVlc3QucXVlcnlbQ1JFREVOVElBTF9RVUVSWV9QQVJBTV0gPSBgJHtjcmVkZW50aWFscy5hY2Nlc3NLZXlJZH0vJHtzY29wZX1gO1xuICAgIHJlcXVlc3QucXVlcnlbQU1aX0RBVEVfUVVFUllfUEFSQU1dID0gbG9uZ0RhdGU7XG4gICAgcmVxdWVzdC5xdWVyeVtFWFBJUkVTX1FVRVJZX1BBUkFNXSA9IGV4cGlyZXNJbi50b1N0cmluZygxMCk7XG5cbiAgICBjb25zdCBjYW5vbmljYWxIZWFkZXJzID0gZ2V0Q2Fub25pY2FsSGVhZGVycyhyZXF1ZXN0LCB1bnNpZ25hYmxlSGVhZGVycywgc2lnbmFibGVIZWFkZXJzKTtcbiAgICByZXF1ZXN0LnF1ZXJ5W1NJR05FRF9IRUFERVJTX1FVRVJZX1BBUkFNXSA9IGdldENhbm9uaWNhbEhlYWRlckxpc3QoY2Fub25pY2FsSGVhZGVycyk7XG5cbiAgICByZXF1ZXN0LnF1ZXJ5W1NJR05BVFVSRV9RVUVSWV9QQVJBTV0gPSBhd2FpdCB0aGlzLmdldFNpZ25hdHVyZShcbiAgICAgIGxvbmdEYXRlLFxuICAgICAgc2NvcGUsXG4gICAgICB0aGlzLmdldFNpZ25pbmdLZXkoY3JlZGVudGlhbHMsIHJlZ2lvbiwgc2hvcnREYXRlLCBzaWduaW5nU2VydmljZSksXG4gICAgICB0aGlzLmNyZWF0ZUNhbm9uaWNhbFJlcXVlc3QocmVxdWVzdCwgY2Fub25pY2FsSGVhZGVycywgYXdhaXQgZ2V0UGF5bG9hZEhhc2gob3JpZ2luYWxSZXF1ZXN0LCB0aGlzLnNoYTI1NikpXG4gICAgKTtcblxuICAgIHJldHVybiByZXF1ZXN0O1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHNpZ24oc3RyaW5nVG9TaWduOiBzdHJpbmcsIG9wdGlvbnM/OiBTaWduaW5nQXJndW1lbnRzKTogUHJvbWlzZTxzdHJpbmc+O1xuICBwdWJsaWMgYXN5bmMgc2lnbihldmVudDogRm9ybWF0dGVkRXZlbnQsIG9wdGlvbnM6IEV2ZW50U2lnbmluZ0FyZ3VtZW50cyk6IFByb21pc2U8c3RyaW5nPjtcbiAgcHVibGljIGFzeW5jIHNpZ24ocmVxdWVzdFRvU2lnbjogSHR0cFJlcXVlc3QsIG9wdGlvbnM/OiBSZXF1ZXN0U2lnbmluZ0FyZ3VtZW50cyk6IFByb21pc2U8SHR0cFJlcXVlc3Q+O1xuICBwdWJsaWMgYXN5bmMgc2lnbih0b1NpZ246IGFueSwgb3B0aW9uczogYW55KTogUHJvbWlzZTxhbnk+IHtcbiAgICBpZiAodHlwZW9mIHRvU2lnbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHRoaXMuc2lnblN0cmluZyh0b1NpZ24sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAodG9TaWduLmhlYWRlcnMgJiYgdG9TaWduLnBheWxvYWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNpZ25FdmVudCh0b1NpZ24sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5zaWduUmVxdWVzdCh0b1NpZ24sIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgc2lnbkV2ZW50KFxuICAgIHsgaGVhZGVycywgcGF5bG9hZCB9OiBGb3JtYXR0ZWRFdmVudCxcbiAgICB7IHNpZ25pbmdEYXRlID0gbmV3IERhdGUoKSwgcHJpb3JTaWduYXR1cmUsIHNpZ25pbmdSZWdpb24sIHNpZ25pbmdTZXJ2aWNlIH06IEV2ZW50U2lnbmluZ0FyZ3VtZW50c1xuICApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IHJlZ2lvbiA9IHNpZ25pbmdSZWdpb24gPz8gKGF3YWl0IHRoaXMucmVnaW9uUHJvdmlkZXIoKSk7XG4gICAgY29uc3QgeyBzaG9ydERhdGUsIGxvbmdEYXRlIH0gPSBmb3JtYXREYXRlKHNpZ25pbmdEYXRlKTtcbiAgICBjb25zdCBzY29wZSA9IGNyZWF0ZVNjb3BlKHNob3J0RGF0ZSwgcmVnaW9uLCBzaWduaW5nU2VydmljZSA/PyB0aGlzLnNlcnZpY2UpO1xuICAgIGNvbnN0IGhhc2hlZFBheWxvYWQgPSBhd2FpdCBnZXRQYXlsb2FkSGFzaCh7IGhlYWRlcnM6IHt9LCBib2R5OiBwYXlsb2FkIH0gYXMgYW55LCB0aGlzLnNoYTI1Nik7XG4gICAgY29uc3QgaGFzaCA9IG5ldyB0aGlzLnNoYTI1NigpO1xuICAgIGhhc2gudXBkYXRlKGhlYWRlcnMpO1xuICAgIGNvbnN0IGhhc2hlZEhlYWRlcnMgPSB0b0hleChhd2FpdCBoYXNoLmRpZ2VzdCgpKTtcbiAgICBjb25zdCBzdHJpbmdUb1NpZ24gPSBbXG4gICAgICBFVkVOVF9BTEdPUklUSE1fSURFTlRJRklFUixcbiAgICAgIGxvbmdEYXRlLFxuICAgICAgc2NvcGUsXG4gICAgICBwcmlvclNpZ25hdHVyZSxcbiAgICAgIGhhc2hlZEhlYWRlcnMsXG4gICAgICBoYXNoZWRQYXlsb2FkLFxuICAgIF0uam9pbihcIlxcblwiKTtcbiAgICByZXR1cm4gdGhpcy5zaWduU3RyaW5nKHN0cmluZ1RvU2lnbiwgeyBzaWduaW5nRGF0ZSwgc2lnbmluZ1JlZ2lvbjogcmVnaW9uLCBzaWduaW5nU2VydmljZSB9KTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgc2lnblN0cmluZyhcbiAgICBzdHJpbmdUb1NpZ246IHN0cmluZyxcbiAgICB7IHNpZ25pbmdEYXRlID0gbmV3IERhdGUoKSwgc2lnbmluZ1JlZ2lvbiwgc2lnbmluZ1NlcnZpY2UgfTogU2lnbmluZ0FyZ3VtZW50cyA9IHt9XG4gICk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgY3JlZGVudGlhbHMgPSBhd2FpdCB0aGlzLmNyZWRlbnRpYWxQcm92aWRlcigpO1xuICAgIGNvbnN0IHJlZ2lvbiA9IHNpZ25pbmdSZWdpb24gPz8gKGF3YWl0IHRoaXMucmVnaW9uUHJvdmlkZXIoKSk7XG4gICAgY29uc3QgeyBzaG9ydERhdGUgfSA9IGZvcm1hdERhdGUoc2lnbmluZ0RhdGUpO1xuXG4gICAgY29uc3QgaGFzaCA9IG5ldyB0aGlzLnNoYTI1Nihhd2FpdCB0aGlzLmdldFNpZ25pbmdLZXkoY3JlZGVudGlhbHMsIHJlZ2lvbiwgc2hvcnREYXRlLCBzaWduaW5nU2VydmljZSkpO1xuICAgIGhhc2gudXBkYXRlKHN0cmluZ1RvU2lnbik7XG4gICAgcmV0dXJuIHRvSGV4KGF3YWl0IGhhc2guZGlnZXN0KCkpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBzaWduUmVxdWVzdChcbiAgICByZXF1ZXN0VG9TaWduOiBIdHRwUmVxdWVzdCxcbiAgICB7XG4gICAgICBzaWduaW5nRGF0ZSA9IG5ldyBEYXRlKCksXG4gICAgICBzaWduYWJsZUhlYWRlcnMsXG4gICAgICB1bnNpZ25hYmxlSGVhZGVycyxcbiAgICAgIHNpZ25pbmdSZWdpb24sXG4gICAgICBzaWduaW5nU2VydmljZSxcbiAgICB9OiBSZXF1ZXN0U2lnbmluZ0FyZ3VtZW50cyA9IHt9XG4gICk6IFByb21pc2U8SHR0cFJlcXVlc3Q+IHtcbiAgICBjb25zdCBjcmVkZW50aWFscyA9IGF3YWl0IHRoaXMuY3JlZGVudGlhbFByb3ZpZGVyKCk7XG4gICAgY29uc3QgcmVnaW9uID0gc2lnbmluZ1JlZ2lvbiA/PyAoYXdhaXQgdGhpcy5yZWdpb25Qcm92aWRlcigpKTtcbiAgICBjb25zdCByZXF1ZXN0ID0gcHJlcGFyZVJlcXVlc3QocmVxdWVzdFRvU2lnbik7XG4gICAgY29uc3QgeyBsb25nRGF0ZSwgc2hvcnREYXRlIH0gPSBmb3JtYXREYXRlKHNpZ25pbmdEYXRlKTtcbiAgICBjb25zdCBzY29wZSA9IGNyZWF0ZVNjb3BlKHNob3J0RGF0ZSwgcmVnaW9uLCBzaWduaW5nU2VydmljZSA/PyB0aGlzLnNlcnZpY2UpO1xuXG4gICAgcmVxdWVzdC5oZWFkZXJzW0FNWl9EQVRFX0hFQURFUl0gPSBsb25nRGF0ZTtcbiAgICBpZiAoY3JlZGVudGlhbHMuc2Vzc2lvblRva2VuKSB7XG4gICAgICByZXF1ZXN0LmhlYWRlcnNbVE9LRU5fSEVBREVSXSA9IGNyZWRlbnRpYWxzLnNlc3Npb25Ub2tlbjtcbiAgICB9XG5cbiAgICBjb25zdCBwYXlsb2FkSGFzaCA9IGF3YWl0IGdldFBheWxvYWRIYXNoKHJlcXVlc3QsIHRoaXMuc2hhMjU2KTtcbiAgICBpZiAoIWhhc0hlYWRlcihTSEEyNTZfSEVBREVSLCByZXF1ZXN0LmhlYWRlcnMpICYmIHRoaXMuYXBwbHlDaGVja3N1bSkge1xuICAgICAgcmVxdWVzdC5oZWFkZXJzW1NIQTI1Nl9IRUFERVJdID0gcGF5bG9hZEhhc2g7XG4gICAgfVxuXG4gICAgY29uc3QgY2Fub25pY2FsSGVhZGVycyA9IGdldENhbm9uaWNhbEhlYWRlcnMocmVxdWVzdCwgdW5zaWduYWJsZUhlYWRlcnMsIHNpZ25hYmxlSGVhZGVycyk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgdGhpcy5nZXRTaWduYXR1cmUoXG4gICAgICBsb25nRGF0ZSxcbiAgICAgIHNjb3BlLFxuICAgICAgdGhpcy5nZXRTaWduaW5nS2V5KGNyZWRlbnRpYWxzLCByZWdpb24sIHNob3J0RGF0ZSwgc2lnbmluZ1NlcnZpY2UpLFxuICAgICAgdGhpcy5jcmVhdGVDYW5vbmljYWxSZXF1ZXN0KHJlcXVlc3QsIGNhbm9uaWNhbEhlYWRlcnMsIHBheWxvYWRIYXNoKVxuICAgICk7XG5cbiAgICByZXF1ZXN0LmhlYWRlcnNbQVVUSF9IRUFERVJdID1cbiAgICAgIGAke0FMR09SSVRITV9JREVOVElGSUVSfSBgICtcbiAgICAgIGBDcmVkZW50aWFsPSR7Y3JlZGVudGlhbHMuYWNjZXNzS2V5SWR9LyR7c2NvcGV9LCBgICtcbiAgICAgIGBTaWduZWRIZWFkZXJzPSR7Z2V0Q2Fub25pY2FsSGVhZGVyTGlzdChjYW5vbmljYWxIZWFkZXJzKX0sIGAgK1xuICAgICAgYFNpZ25hdHVyZT0ke3NpZ25hdHVyZX1gO1xuXG4gICAgcmV0dXJuIHJlcXVlc3Q7XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZUNhbm9uaWNhbFJlcXVlc3QocmVxdWVzdDogSHR0cFJlcXVlc3QsIGNhbm9uaWNhbEhlYWRlcnM6IEhlYWRlckJhZywgcGF5bG9hZEhhc2g6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3Qgc29ydGVkSGVhZGVycyA9IE9iamVjdC5rZXlzKGNhbm9uaWNhbEhlYWRlcnMpLnNvcnQoKTtcbiAgICByZXR1cm4gYCR7cmVxdWVzdC5tZXRob2R9XG4ke3RoaXMuZ2V0Q2Fub25pY2FsUGF0aChyZXF1ZXN0KX1cbiR7Z2V0Q2Fub25pY2FsUXVlcnkocmVxdWVzdCl9XG4ke3NvcnRlZEhlYWRlcnMubWFwKChuYW1lKSA9PiBgJHtuYW1lfToke2Nhbm9uaWNhbEhlYWRlcnNbbmFtZV19YCkuam9pbihcIlxcblwiKX1cblxuJHtzb3J0ZWRIZWFkZXJzLmpvaW4oXCI7XCIpfVxuJHtwYXlsb2FkSGFzaH1gO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBjcmVhdGVTdHJpbmdUb1NpZ24oXG4gICAgbG9uZ0RhdGU6IHN0cmluZyxcbiAgICBjcmVkZW50aWFsU2NvcGU6IHN0cmluZyxcbiAgICBjYW5vbmljYWxSZXF1ZXN0OiBzdHJpbmdcbiAgKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zdCBoYXNoID0gbmV3IHRoaXMuc2hhMjU2KCk7XG4gICAgaGFzaC51cGRhdGUoY2Fub25pY2FsUmVxdWVzdCk7XG4gICAgY29uc3QgaGFzaGVkUmVxdWVzdCA9IGF3YWl0IGhhc2guZGlnZXN0KCk7XG5cbiAgICByZXR1cm4gYCR7QUxHT1JJVEhNX0lERU5USUZJRVJ9XG4ke2xvbmdEYXRlfVxuJHtjcmVkZW50aWFsU2NvcGV9XG4ke3RvSGV4KGhhc2hlZFJlcXVlc3QpfWA7XG4gIH1cblxuICBwcml2YXRlIGdldENhbm9uaWNhbFBhdGgoeyBwYXRoIH06IEh0dHBSZXF1ZXN0KTogc3RyaW5nIHtcbiAgICBpZiAodGhpcy51cmlFc2NhcGVQYXRoKSB7XG4gICAgICBjb25zdCBkb3VibGVFbmNvZGVkID0gZW5jb2RlVVJJQ29tcG9uZW50KHBhdGgucmVwbGFjZSgvXlxcLy8sIFwiXCIpKTtcbiAgICAgIHJldHVybiBgLyR7ZG91YmxlRW5jb2RlZC5yZXBsYWNlKC8lMkYvZywgXCIvXCIpfWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdldFNpZ25hdHVyZShcbiAgICBsb25nRGF0ZTogc3RyaW5nLFxuICAgIGNyZWRlbnRpYWxTY29wZTogc3RyaW5nLFxuICAgIGtleVByb21pc2U6IFByb21pc2U8VWludDhBcnJheT4sXG4gICAgY2Fub25pY2FsUmVxdWVzdDogc3RyaW5nXG4gICk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3Qgc3RyaW5nVG9TaWduID0gYXdhaXQgdGhpcy5jcmVhdGVTdHJpbmdUb1NpZ24obG9uZ0RhdGUsIGNyZWRlbnRpYWxTY29wZSwgY2Fub25pY2FsUmVxdWVzdCk7XG5cbiAgICBjb25zdCBoYXNoID0gbmV3IHRoaXMuc2hhMjU2KGF3YWl0IGtleVByb21pc2UpO1xuICAgIGhhc2gudXBkYXRlKHN0cmluZ1RvU2lnbik7XG4gICAgcmV0dXJuIHRvSGV4KGF3YWl0IGhhc2guZGlnZXN0KCkpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRTaWduaW5nS2V5KFxuICAgIGNyZWRlbnRpYWxzOiBDcmVkZW50aWFscyxcbiAgICByZWdpb246IHN0cmluZyxcbiAgICBzaG9ydERhdGU6IHN0cmluZyxcbiAgICBzZXJ2aWNlPzogc3RyaW5nXG4gICk6IFByb21pc2U8VWludDhBcnJheT4ge1xuICAgIHJldHVybiBnZXRTaWduaW5nS2V5KHRoaXMuc2hhMjU2LCBjcmVkZW50aWFscywgc2hvcnREYXRlLCByZWdpb24sIHNlcnZpY2UgfHwgdGhpcy5zZXJ2aWNlKTtcbiAgfVxufVxuXG5jb25zdCBmb3JtYXREYXRlID0gKG5vdzogRGF0ZUlucHV0KTogeyBsb25nRGF0ZTogc3RyaW5nOyBzaG9ydERhdGU6IHN0cmluZyB9ID0+IHtcbiAgY29uc3QgbG9uZ0RhdGUgPSBpc284NjAxKG5vdykucmVwbGFjZSgvW1xcLTpdL2csIFwiXCIpO1xuICByZXR1cm4ge1xuICAgIGxvbmdEYXRlLFxuICAgIHNob3J0RGF0ZTogbG9uZ0RhdGUuc3Vic3RyKDAsIDgpLFxuICB9O1xufTtcblxuY29uc3QgZ2V0Q2Fub25pY2FsSGVhZGVyTGlzdCA9IChoZWFkZXJzOiBvYmplY3QpOiBzdHJpbmcgPT4gT2JqZWN0LmtleXMoaGVhZGVycykuc29ydCgpLmpvaW4oXCI7XCIpO1xuXG5jb25zdCBub3JtYWxpemVSZWdpb25Qcm92aWRlciA9IChyZWdpb246IHN0cmluZyB8IFByb3ZpZGVyPHN0cmluZz4pOiBQcm92aWRlcjxzdHJpbmc+ID0+IHtcbiAgaWYgKHR5cGVvZiByZWdpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCBwcm9taXNpZmllZCA9IFByb21pc2UucmVzb2x2ZShyZWdpb24pO1xuICAgIHJldHVybiAoKSA9PiBwcm9taXNpZmllZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVnaW9uO1xuICB9XG59O1xuXG5jb25zdCBub3JtYWxpemVDcmVkZW50aWFsc1Byb3ZpZGVyID0gKGNyZWRlbnRpYWxzOiBDcmVkZW50aWFscyB8IFByb3ZpZGVyPENyZWRlbnRpYWxzPik6IFByb3ZpZGVyPENyZWRlbnRpYWxzPiA9PiB7XG4gIGlmICh0eXBlb2YgY3JlZGVudGlhbHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICBjb25zdCBwcm9taXNpZmllZCA9IFByb21pc2UucmVzb2x2ZShjcmVkZW50aWFscyk7XG4gICAgcmV0dXJuICgpID0+IHByb21pc2lmaWVkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVkZW50aWFscztcbiAgfVxufTtcbiJdfQ==